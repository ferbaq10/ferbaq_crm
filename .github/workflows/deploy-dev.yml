name: Deploy to EC2 (Branch)

on:
  push:
    branches:
      - develop
      - features/client      # Cambia esto por el patrón de tu rama
  workflow_dispatch:    # Permite ejecución manual opcional

env:
  DEPLOYMENT_TIMEOUT: 600  # 10 minutos timeout

jobs:
  deploy:
    name: Deploy to EC2
    runs-on: ubuntu-latest
    environment: development

    steps:
    - name: Checkout código
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Determinar rama y entorno
      run: |
        echo "RAMA_ACTUAL=${{ github.ref_name }}" >> $GITHUB_ENV
        echo "RAMA_ACTUAL_SIMPLE=$(echo '${{ github.ref_name }}' | sed 's/[^a-zA-Z0-9]/-/g')" >> $GITHUB_ENV
        echo "La rama actual es: ${{ github.ref_name }}"

    - name: Configurar SSH
      run: |
        mkdir -p ~/.ssh
        echo "${{ secrets.EC2_SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
        chmod 600 ~/.ssh/id_rsa
        ssh-keyscan -H ${{ secrets.EC2_HOST }} >> ~/.ssh/known_hosts

    - name: Verificar conectividad SSH
      run: ssh -o ConnectTimeout=10 ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} "echo 'Conexión SSH exitosa'"

    - name: Deploy en EC2
      timeout-minutes: 10
      run: |
        ssh -o ConnectTimeout=10 ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} << 'EOF'
          set -euo pipefail
          
          BRANCH_NAME="${{ env.RAMA_ACTUAL }}"
          BRANCH_SIMPLE="${{ env.RAMA_ACTUAL_SIMPLE }}"
          PROJECT_DIR="${{ secrets.EC2_PROJECT_DIR }}/$BRANCH_SIMPLE"
          VENV_PATH="$PROJECT_DIR/venv"
          BACKUP_DIR="$PROJECT_DIR/backups"
          TIMESTAMP=$(date +%Y%m%d_%H%M%S)
          REPO_URL="https://github.com/${{ github.repository }}.git"

          echo "Iniciando deploy de la rama: $BRANCH_NAME"
          echo "Directorio del proyecto: $PROJECT_DIR"
          echo "URL del repositorio: $REPO_URL"
          
          # Crear directorio del proyecto si no existe
          mkdir -p "$PROJECT_DIR"
          
          # Backup si existe contenido previo
          if [ -d "$PROJECT_DIR" ] && [ "$(ls -A $PROJECT_DIR)" ]; then
            mkdir -p "$BACKUP_DIR"
            if [ -f "$PROJECT_DIR/manage.py" ]; then
              echo "Creando backup..."
              tar -czf "$BACKUP_DIR/backup_$TIMESTAMP.tar.gz" \
                --exclude='venv' --exclude='__pycache__' --exclude='*.pyc' \
                --exclude='logs' --exclude='backups' -C "$PROJECT_DIR" . 2>/dev/null || true
            fi
          fi

          cd "$PROJECT_DIR"

          # Lógica de git mejorada
          if [ ! -d ".git" ]; then
            echo "Clonando repositorio por primera vez..."
            rm -rf * .* 2>/dev/null || true  # Limpiar directorio
            git clone "$REPO_URL" . || {
              echo "Error al clonar. Intentando inicializar manualmente..."
              git init
              git remote add origin "$REPO_URL"
            }
          fi

          # Verificar y configurar remote
          if ! git remote get-url origin >/dev/null 2>&1; then
            echo "Configurando remote origin..."
            git remote add origin "$REPO_URL" 2>/dev/null || git remote set-url origin "$REPO_URL"
          fi

          # Fetch y checkout de la rama
          echo "Actualizando código..."
          git fetch origin --prune || {
            echo "Error en fetch. Reintentando..."
            git remote set-url origin "$REPO_URL"
            git fetch origin --prune
          }

          # Checkout de la rama específica
          if git show-ref --verify --quiet "refs/remotes/origin/$BRANCH_NAME"; then
            echo "Cambiando a la rama $BRANCH_NAME"
            git checkout -B "$BRANCH_NAME" "origin/$BRANCH_NAME"
          else
            echo "ERROR: La rama $BRANCH_NAME no existe en el repositorio remoto"
            exit 1
          fi

          git clean -fd

          # Virtualenv
          echo "Configurando entorno virtual..."
          if [ ! -d "$VENV_PATH" ]; then
            python3 -m venv "$VENV_PATH"
          fi
          source "$VENV_PATH/bin/activate"

          # Verificar que tenemos requirements.txt
          if [ ! -f "requirements.txt" ]; then
            echo "ERROR: No se encontró requirements.txt"
            exit 1
          fi

          # Dependencias
          echo "Instalando dependencias..."
          python -m pip install --upgrade pip
          python -m pip install -r requirements.txt

          # Configuración específica por rama
          echo "Creando archivo .env..."
          cat > .env << EOL
          DEBUG=True
          SECRET_KEY='${{ secrets.DJANGO_SECRET_KEY }}'
          DATABASE_URL='${{ secrets.DATABASE_URL }}'
          ALLOWED_HOSTS='${{ secrets.ALLOWED_HOSTS }},localhost,127.0.0.1'
          CORS_ALLOWED_ORIGINS='${{ secrets.CORS_ALLOWED_ORIGINS }}'
          REDIS_URL='${{ secrets.REDIS_URL }}'
          EMAIL_HOST='${{ secrets.EMAIL_HOST }}'
          EMAIL_HOST_USER='${{ secrets.EMAIL_HOST_USER }}'
          EMAIL_HOST_PASSWORD='${{ secrets.EMAIL_HOST_PASSWORD }}'
          FRONTEND_URL='${{ secrets.FRONTEND_URL }}'
          BRANCH_NAME='$BRANCH_NAME'
          EOL
          chmod 600 .env

          # Verificar que tenemos manage.py
          if [ ! -f "manage.py" ]; then
            echo "ERROR: No se encontró manage.py. ¿Es este un proyecto Django?"
            exit 1
          fi

          # Migraciones / estáticos
          echo "Ejecutando migraciones..."
          python manage.py migrate --noinput
          echo "Recolectando archivos estáticos..."
          python manage.py collectstatic --noinput --clear
          python manage.py check --deploy || true

          # Servicios según rama
          if [ "$BRANCH_NAME" = "develop" ]; then
            echo "Reiniciando servicios de producción..."
            sudo systemctl daemon-reload
            sudo systemctl restart gunicorn
            sudo systemctl restart rqworker || true
            
            # Verificar que gunicorn esté activo
            if ! sudo systemctl is-active --quiet gunicorn; then
              echo "ERROR: Gunicorn no está activo"
              sudo systemctl status gunicorn
              exit 1
            fi
            echo "Servicios reiniciados correctamente"
          else
            echo "Rama: $BRANCH_NAME"
            echo "Para iniciar el servidor de desarrollo manualmente:"
            echo "cd $PROJECT_DIR && source venv/bin/activate && python manage.py runserver 0.0.0.0:8000"
          fi

          deactivate

          # Mantener últimos 5 backups
          if [ -d "$BACKUP_DIR" ]; then
            cd "$BACKUP_DIR"
            ls -t backup_*.tar.gz 2>/dev/null | tail -n +6 | xargs -r rm -f
          fi

          echo "✅ Deploy completado exitosamente para la rama $BRANCH_NAME en $TIMESTAMP"
        EOF

    - name: Verificar deploy (solo develop)
      if: env.RAMA_ACTUAL == 'develop'
      env:
        HEALTH_URL: ${{ secrets.HEALTH_URL }}
      run: |
        echo "Esperando que el servicio responda..."
        sleep 15
        for i in {1..10}; do
          code=$(curl -s -o /dev/null -w "%{http_code}" -L --max-time 10 "$HEALTH_URL")
          if [ "$code" -ge 200 ] && [ "$code" -lt 400 ]; then
            echo "✅ Health check OK (HTTP $code) intento $i"
            curl -s --max-time 5 "$HEALTH_URL" | head -c 200 || true
            exit 0
          else
            echo "❌ Health check falló (HTTP $code) intento $i/10"
            sleep 8
          fi
        done
        echo "Deploy verification failed"; exit 1

    - name: Deploy Summary
      if: always()
      run: |
        echo "## Deploy Summary" >> $GITHUB_STEP_SUMMARY
        echo "- **Environment**: Development" >> $GITHUB_STEP_SUMMARY
        echo "- **Branch**: ${{ env.RAMA_ACTUAL }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Commit**: ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Status**: ${{ job.status }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Project Directory**: ${{ secrets.EC2_PROJECT_DIR }}/${{ env.RAMA_ACTUAL_SIMPLE }}" >> $GITHUB_STEP_SUMMARY